h1. TinySite

TinySite is a static small site engine with "Heroku":http://heroku.com and "Dropbox":http://www.dropbox.com/ in mind. The idea is to host the app for a site on Heroku and take advantage of their awesome application stack and provide the static content by Dropbox.

For a guide to get you started immediately have a look at the "TinySite example app repo":https://github.com/niko/TinySite_example_app. The example app may serve you as a blueprint for your own app.

If you like TinySite and don't have a Dropbox account already: Supporting this project by using my "affiliate link":http://db.tt/zhjQbKF would be the easiest possibility to give back. And the best part is: When you use the affiliate link not only me, but you too get 250MB extra space on Dropbox.

h2. Overview

TinySite itself is a tiny (hence the name) pure Rack application, sporting a mere 200 LOC.

As already stated TinySite was designed with Heroku and Dropbox in mind. But of course TinySite will work at any other "Ruby":http://www.ruby-lang.org hoster as well and is easy to be self hosted (it's just "Rack":http://rack.rubyforge.org). And of course any other HTTP server or even local files will work for the content.

With the Heroku/Dropbox combination TinySite provides:

* Easy local editing of "YAML":http://en.wikipedia.org/wiki/YAML & "Textile":http://en.wikipedia.org/wiki/Textile_(markup_language) based _page content files_.
* Versioning of _page content files_.
* Give other people access to edit all pages or just some (via Dropbox folder sharing).
* Easy drag and drop image (and other asset) upload.
* Edit page form your iPhone or Android phone (via Dropbox edit app).
* An own Heroku subdomain (and it's cheap to register an own domain for it).
* Take full advantage of Herokus caching infrastructure.

So how does it work?

h2. The layout

Each page is rendered into a "HAML":http://haml-lang.com layout file. The parts of the page and a set of variables are provided by the page itself and a _global content file_. The layout file should be located next to the rackup file @config.ru@ and defaults to @layout.haml@. The layout file is configurable via @page[:layout]@ and @global[:layout]@.

A minimal @layout.haml@ could look like this:

<pre><code>!!!
%html{:lang => "de"}
  %head
    %meta{:charset => "utf-8"}
    %title= page[:title] || global[:title]
    %link{:href => "/stylesheets/styles.css"}
  %body
    %header
    %h1 Some title
    %nav
      = global['navigation']
    %aside
      = page['sidebar']
    %section
      = page['body']
    %footer
</code></pre>

Note the use of @page[:title]@, @global[:title]@, @global['navigation']@, @page['sidebar']@ and @page['body']@. These variables are defined via...

h2. The _page content files_

... basically look like this:

<pre><code>---
:title: My Page
:description: It's uber-awesome!

++++sidebar++++

!some.png!

Orem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

++++body++++

h1. Hey, Dude!

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
</code></pre>

This gives the layout access to these variables: @page[:title]@, @page[:description]@, @page['sidebar']@ and @page['body']@.

Analog to the @page@ variables the @global@ variables are set via the content of the @__global.textile@ file. A typical one would perhaps look like this:

<pre><code>---
:keywords: bla, blub, ...

++++navigation++++

* "Home":/
* "One":one
</code></pre>

With this in place the layout has access to these variables: @global[:keywords]@ and @global['navigation']@. The @__global@ file would be the place to add a footer, too.

The filenames derive directly from the path. Subfolders are supported. With the above navigation in place you would need an @index.textile@ file and a @one.textile@ file next to your @__global.textile@ file.

Besides the @page@ and the @global@ variable the layout hast access to a @env@ hash containing the current path and the current query string: @env[:path]@ and @env[:query_string]@.

h2. The app itself

The app itself is really, really simple. All you need to get started is a @config.ru@ file:

<pre><code>require 'tiny_site'

use Rack::ContentLength

run TinySite.new :file_path => 'http://dl.dropbox.com/u/[user_id]/my_site'
</code></pre>

The file path would be the folder in which the _page content files_ are available. Other supported parameters are @:image_path@ (defaults to @[file_path]/images@) and @cache_buster@ (a query string with which you can bust the internal cache and prevent HTTP caching for the given site). The @:image_path@ helps to keep urls of images in your textile short. Image tags which don't start with 'http://' or '/' will be prefixed by the @:image_path@.

Of course you will want to serve some assets, too. Give this files and folders:

<pre><code>config.ru
layout.haml
public/
  javascript/
    my.js
  stylesheets/
    my.css
</code></pre>

In this case the @config.ru@ will more look like this:

<pre><code>require 'tiny_site'

use Rack::CommonLogger
use Rack::ContentLength
use Rack::Static, :urls => ['/stylesheets','/javascript'], :root => 'public'

run TinySite.new :cache_buster => 'preview',
                 :file_path => 'http://dl.dropbox.com/u/1343338/a_test',
                 :image_path => 'http://dl.dropbox.com/u/1343338/a_test/images',
                 :file_extension => :txt
</code></pre>

The file_extension is configurable if you need to use an editor that doesn't want to edit .textile files. Such as some smartphone dropbox clients which can only edit .txt files or the "TextDrop":http://textdropapp.com/ web client. I tried "Droptext for iPhone":http://itunes.apple.com/us/app/droptext-a-text-editor-for/id371880635?mt=8 and it works nicely! .textile can be added to the known extensions.

h2. Caching

TinySite adds HTTP caching headers to support Herokus Varnish cache. In addition to that fetched textile files are cached in-app for up to an hour. You can bust the cache by adding a configurable cache-busting query string. By default it's @bust@, so you would just add it to the URL like this: @http://foo/bar?bust@. In addition to clear the internal cache this adds a cache-control header to prevent caching in any HTTP cache between you and the app.

You can use the cache buster to make changes to the page immediately visible for you to review them (and still others will _most likely_ get the old version for quite some time). I couldn't figure out a possibility to expire Herokus Varnish cache on demand, so at the moment you have no control over when exactly changes made are visible. It could take up to two hours (one for the internal content file cache and one for the external HTTP cache). As stated you can clear the internal cache of all pages by adding the cache buster query string and cut the time to max one hour.

It would be a good idea to choose an own cache buster query string and keep it somewhat secret so other people can't fiddle with your apps cache.

h2. ToDo

* Perhaps add a helper for the layout?

h2. Credits

* "Floran Hanke":https://github.com/floere for constant feedback

h2. Current state of TinySite

TinySite is currently alpha software. Patches and Bugreports are welcome.

h2. Licence

It's MIT licensed. See the License file for details.

